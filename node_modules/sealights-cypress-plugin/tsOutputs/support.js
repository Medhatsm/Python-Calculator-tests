"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const const_1 = require("./const");
const sealights_service_1 = require("./sealights-service");
const utils_1 = require("./utils");
function registerHooks() {
    before(function () {
        cy.task(const_1.SL_START_TEST_SESSION).then({ timeout: 20000 }, (excludedTests) => {
            markExcludedTests(this.test.parent, excludedTests);
        });
    });
    after(() => {
        cy.window().then(() => __awaiter(this, void 0, void 0, function* () {
            const currentTimeout = Cypress.config('defaultCommandTimeout');
            const timeoutPromise = new Promise((resolve) => {
                setTimeout(() => resolve(null), currentTimeout - 100);
            });
            cy.window().then((win) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                if (typeof ((_a = win === null || win === void 0 ? void 0 : win.$SealightsAgent) === null || _a === void 0 ? void 0 : _a.sendAllFootprints) !== 'function') {
                    return;
                }
                yield Promise.race([(_c = (_b = win === null || win === void 0 ? void 0 : win.$SealightsAgent) === null || _b === void 0 ? void 0 : _b.sendAllFootprints) === null || _c === void 0 ? void 0 : _c.call(_b), timeoutPromise]);
            }));
            cy.task(const_1.SL_END_TEST_SESSION);
        }));
    });
    beforeEach(() => {
        cy.window().then((win) => __awaiter(this, void 0, void 0, function* () {
            const agentLoaded = yield (0, utils_1.checkAgentLoaded)(win, 100, 1);
            if (!agentLoaded) {
                return;
            }
            const testName = Cypress.currentTest.title;
            const customEvent = new CustomEvent(const_1.SL_COLORING_EVENTS.SET_CONTEXT, {
                detail: {
                    baggage: {
                        [const_1.SL_COLORING_HEADERS.TEST_NAME]: testName,
                        [const_1.SL_COLORING_HEADERS.TEST_SESSION_ID]: sealights_service_1.SealightsTestSessionService._testSessionId,
                    },
                },
            });
            win.dispatchEvent(customEvent);
        }));
    });
    afterEach(function () {
        const currentTest = this.currentTest;
        const duration = currentTest.duration;
        const testName = currentTest.title;
        const suiteName = currentTest.parent.title;
        const state = currentTest.state;
        cy.task(const_1.SL_REPORT_TEST_END_TASK, { testName, suiteName, duration, state });
    });
    afterEach(() => {
        const currentTimeout = Cypress.config('defaultCommandTimeout');
        const timeoutPromise = new Promise((resolve) => {
            setTimeout(() => resolve(null), currentTimeout - 100);
        });
        cy.window().then((win) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            if (typeof ((_a = win === null || win === void 0 ? void 0 : win.$SealightsAgent) === null || _a === void 0 ? void 0 : _a.sendAllFootprints) !== 'function') {
                return;
            }
            yield Promise.race([(_c = (_b = win === null || win === void 0 ? void 0 : win.$SealightsAgent) === null || _b === void 0 ? void 0 : _b.sendAllFootprints) === null || _c === void 0 ? void 0 : _c.call(_b), timeoutPromise]);
        }));
    });
    function markExcludedTests(suite, excludedTests) {
        if (!excludedTests) {
            return;
        }
        suite.suites.forEach((suite) => markExcludedTests(suite, excludedTests));
        suite.tests.forEach((test) => {
            test.pending = excludedTests[(0, utils_1.constructTestName)(suite.title, test.title)] ? true : test.pending;
        });
    }
}
if (Cypress.env(const_1.SL_TASKS_REGISTERED) !== true) {
    registerHooks();
}
//# sourceMappingURL=support.js.map