"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SealightsTestSessionService = void 0;
const axios_1 = require("axios");
const jwt_decode_1 = require("jwt-decode");
const const_1 = require("./const");
const utils_1 = require("./utils");
class TestSessionService {
    constructor() {
        this.apiToken = null;
        this.baseUrl = null;
        this.buildSessionId = null;
        this.labId = null;
        this.testStage = null;
        this.testSessionId = null;
        this.testSessionsV1Instance = null;
        this.testSessionsV2Instance = null;
        this.excludedTests = null;
        this.configurationError = false;
    }
    static getInstance() {
        if (!TestSessionService.instance) {
            TestSessionService.instance = new TestSessionService();
        }
        return TestSessionService.instance;
    }
    setConfig(apiToken, testStage, buildSessionId, labId) {
        if (!(buildSessionId === null || buildSessionId === void 0 ? void 0 : buildSessionId.length) && !(labId === null || labId === void 0 ? void 0 : labId.length)) {
            this.configurationError = true;
            throw new Error(`${const_1.SL_LOG_PREFIX} At least one of buildSessionId/labId must be provided for Sealights integration. Test suite will resume with disabled integration.`);
        }
        let decodedToken = null;
        try {
            decodedToken = (0, jwt_decode_1.default)(apiToken);
        }
        catch (e) {
            this.configurationError = true;
            throw new Error(`${const_1.SL_LOG_PREFIX} Invalid Sealights Token provided, could not be decoded. Test suite will resume with disabled integration.`);
        }
        this.baseUrl = decodedToken[const_1.X_SL_SERVER];
        this.apiToken = apiToken;
        this.buildSessionId = buildSessionId;
        this.labId = labId;
        this.testStage = testStage;
        this.createInstanceV1();
        this.createInstanceV2();
    }
    createInstanceV1() {
        var _a;
        this.testSessionsV1Instance = axios_1.default.create({
            baseURL: (_a = this.baseUrl) === null || _a === void 0 ? void 0 : _a.replace('/api', '/sl-api/v1/test-sessions'),
            headers: {
                Authorization: `Bearer ${this.apiToken}`,
            },
        });
    }
    createInstanceV2() {
        var _a;
        this.testSessionsV2Instance = axios_1.default.create({
            baseURL: (_a = this.baseUrl) === null || _a === void 0 ? void 0 : _a.replace('/api', '/sl-api/v2/test-sessions'),
            headers: {
                Authorization: `Bearer ${this.apiToken}`,
            },
        });
    }
    createTestSession(testStage = this.testStage) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield ((_a = this.testSessionsV1Instance) === null || _a === void 0 ? void 0 : _a.post('/', {
                testStage,
                bsid: this.buildSessionId,
                labid: this.labId,
            }));
            this.testSessionId = data.data.testSessionId;
            console.log(`${const_1.SL_LOG_PREFIX} Test session successfully created.`);
        });
    }
    endTestSession() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield ((_a = this.testSessionsV1Instance) === null || _a === void 0 ? void 0 : _a.delete(`/${this.testSessionId}`));
            console.log(`${const_1.SL_LOG_PREFIX} Test session successfully ended.`);
        });
    }
    getTestRecommendations() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.excludedTests) {
                return this.excludedTests;
            }
            try {
                const { data } = yield ((_a = this.testSessionsV1Instance) === null || _a === void 0 ? void 0 : _a.get(`/${this.testSessionId}/exclude-tests`));
                this.excludedTests = (((_b = data === null || data === void 0 ? void 0 : data.data) === null || _b === void 0 ? void 0 : _b.length) ? data.data : []).reduce((acc, testName) => (Object.assign(Object.assign({}, acc), { [testName]: testName })), {});
                console.log(`${const_1.SL_LOG_PREFIX} Test recommendation successfully retrieved. Tests will be marked for exclusion.`);
                return this.excludedTests;
            }
            catch (e) {
                console.log((0, utils_1.sanitizeError)(e));
                this.excludedTests = null;
                return this.excludedTests;
            }
        });
    }
    sendTestEvent(name, start, end, status) {
        var _a;
        if (!!this._excludedTests[name] && status === const_1.TEST_STATUS.PENDING) {
            status = const_1.TEST_STATUS.SKIPPED;
        }
        return (_a = this.testSessionsV2Instance) === null || _a === void 0 ? void 0 : _a.post(`/${this.testSessionId}`, [
            {
                name,
                start,
                end,
                status,
            },
        ]);
    }
    get _testSessionId() {
        return this.testSessionId;
    }
    get _excludedTests() {
        var _a;
        return (_a = this.excludedTests) !== null && _a !== void 0 ? _a : {};
    }
    static runServiceMethodSafe(_, propertyKey, descriptor) {
        const originalMethod = descriptor.value;
        descriptor.value = function (...args) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    if (this.configurationError) {
                        return null;
                    }
                    return yield originalMethod.apply(this, args);
                }
                catch (error) {
                    const sanitizedError = (0, utils_1.sanitizeError)(error);
                    console.log(`${const_1.SL_LOG_PREFIX} An error occurred in method ${propertyKey}:`, sanitizedError);
                }
            });
        };
        return descriptor;
    }
}
__decorate([
    TestSessionService.runServiceMethodSafe
], TestSessionService.prototype, "setConfig", null);
__decorate([
    TestSessionService.runServiceMethodSafe
], TestSessionService.prototype, "createTestSession", null);
__decorate([
    TestSessionService.runServiceMethodSafe
], TestSessionService.prototype, "endTestSession", null);
__decorate([
    TestSessionService.runServiceMethodSafe
], TestSessionService.prototype, "getTestRecommendations", null);
__decorate([
    TestSessionService.runServiceMethodSafe
], TestSessionService.prototype, "sendTestEvent", null);
exports.SealightsTestSessionService = TestSessionService.getInstance();
//# sourceMappingURL=sealights-service.js.map